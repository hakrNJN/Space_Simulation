<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Space Cockpit: Ultimate Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;700&family=Share+Tech+Mono&display=swap');

        :root {
            --hud-primary: #00f0ff;
            --hud-secondary: #ffaa00; /* Solar/Home */
            --hud-tertiary: #0088ff;  /* Target */
            --hud-bg: rgba(5, 10, 15, 0.25);
            --glass-edge: rgba(255, 255, 255, 0.08);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: #000;
        }

        #cockpit-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .top-bar {
            width: 100%;
            height: 60px;
            display: flex;
            justify-content: center;
            padding-top: 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
        }

        .compass-container {
            width: 600px;
            height: 30px;
            overflow: hidden;
            position: relative;
            mask-image: linear-gradient(to right, transparent, black 20%, black 80%, transparent);
            -webkit-mask-image: linear-gradient(to right, transparent, black 20%, black 80%, transparent);
            border-bottom: 1px solid rgba(0, 240, 255, 0.2);
        }

        .compass-tape {
            display: flex;
            position: absolute;
            left: 50%;
            transition: transform 0.1s linear;
        }

        .tick {
            width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--hud-primary);
            font-family: 'Share Tech Mono';
            font-size: 10px;
            height: 20px;
            justify-content: flex-end;
            border-right: 1px solid rgba(0, 240, 255, 0.1);
        }
        .tick.major { border-right: 1px solid var(--hud-primary); color: #fff; font-weight: bold; font-size: 12px; }

        .dashboard-container {
            width: 100%;
            height: 22vh;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            perspective: 1000px;
            padding-bottom: 0;
        }

        .dashboard-glass {
            width: 95%;
            max-width: 1400px;
            height: 100%;
            background: var(--hud-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-top: 1px solid var(--glass-edge);
            border-radius: 60px 60px 0 0;
            transform: rotateX(10deg) translateY(10px);
            transform-origin: bottom center;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
            display: flex;
            padding: 20px 40px;
            box-sizing: border-box;
        }

        .screen-section { flex: 1; display: flex; flex-direction: column; justify-content: center; gap: 8px; }
        .screen-left { align-items: flex-start; border-right: 1px solid rgba(255,255,255,0.05); }
        .screen-right { align-items: flex-end; border-left: 1px solid rgba(255,255,255,0.05); text-align: right; }
        .screen-center { flex: 1.2; align-items: center; justify-content: flex-end; position: relative; padding-bottom: 5px; }

        .data-row { display: flex; align-items: baseline; gap: 10px; }
        .label { font-size: 9px; color: rgba(255,255,255,0.3); letter-spacing: 1px; text-transform: uppercase; white-space: nowrap; }
        .data-value { font-family: 'Share Tech Mono'; font-size: 18px; color: var(--hud-primary); text-shadow: 0 0 5px rgba(0,240,255,0.2); }
        .data-big { font-size: 32px; color: #fff; }
        .unit { font-size: 12px; color: #888; margin-left: 2px; }

        .radar-group {
            position: relative;
            width: 340px;
            height: 140px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
        }

        .steering-handles {
            position: absolute;
            bottom: -10px;
            width: 100%;
            height: 100%;
            z-index: 1;
            filter: drop-shadow(0 5px 10px rgba(0,0,0,0.8));
            transform-origin: center 120%;
            transition: transform 0.1s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }

        .radar-container {
            width: 120px;
            height: 120px;
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 50%;
            position: relative;
            background: radial-gradient(circle, rgba(0,40,60,0.2) 0%, transparent 70%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            z-index: 2;
            margin-bottom: 5px;
        }
        
        .radar-grid {
            position: absolute; width: 100%; height: 100%;
            border-radius: 50%;
            background: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 15px 15px;
        }

        .radar-ship {
            width: 0; height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 10px solid #fff;
            z-index: 5;
        }

        .radar-blip {
            position: absolute; width: 6px; height: 6px; border-radius: 50%;
            transform: translate(-50%, -50%); transition: all 0.1s;
        }
        .blip-target { background-color: var(--hud-tertiary); box-shadow: 0 0 6px var(--hud-tertiary); z-index: 4; }
        .blip-home { background-color: var(--hud-secondary); box-shadow: 0 0 6px var(--hud-secondary); z-index: 3; }

        .touch-btn {
            position: absolute; width: 80px; height: 80px; border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.03);
            backdrop-filter: blur(4px); color: rgba(255,255,255,0.5);
            display: flex; align-items: center; justify-content: center;
            font-size: 11px; pointer-events: auto; transition: transform 0.1s, background 0.1s; z-index: 50;
        }
        .touch-btn:active { background: rgba(0,240,255,0.15); transform: scale(0.95); color: #fff; border-color: var(--hud-primary); }
        
        #btn-warp { right: 20px; bottom: 30vh; }
        #btn-brake { right: 20px; bottom: 18vh; }
        
        .controls-hint {
            position: absolute; top: 20px; left: 20px; font-size: 11px; color: rgba(255,255,255,0.25); line-height: 1.5;
        }

        .reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 30px; height: 30px; border: 1px solid rgba(255,255,255,0.15); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
        }
        .reticle::after { content: ''; width: 3px; height: 3px; background: var(--hud-primary); border-radius: 50%; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <div class="controls-hint">
        MOUSE: Look/Steer<br>
        W / TOUCH: Warp Drive<br>
        S / TOUCH: Brake<br>
        Current Location: Near VEGA
    </div>

    <div id="btn-warp" class="touch-btn">WARP</div>
    <div id="btn-brake" class="touch-btn">BRAKE</div>

    <div id="canvas-container"></div>

    <div id="cockpit-ui">
        <div class="top-bar">
            <div class="compass-container">
                <div class="compass-tape" id="compass-tape"></div>
            </div>
        </div>
        <div class="reticle"></div>

        <div class="dashboard-container">
            <div class="dashboard-glass">
                
                <div class="screen-section screen-left">
                    <div class="data-row">
                        <div class="label">COORDS</div>
                        <div class="data-value" style="font-size: 14px;" id="hud-coords">0, 0, 0</div>
                    </div>
                    <div class="data-row">
                         <div class="label">STATUS</div>
                         <div class="data-value" style="font-size: 14px; color: #0f0;">NOMINAL</div>
                    </div>
                </div>

                <div class="screen-section screen-center">
                    <div class="radar-group">
                        <svg class="steering-handles" id="steering-handle" viewBox="0 0 340 140">
                            <defs>
                                <linearGradient id="metalGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:#444;stop-opacity:1" />
                                    <stop offset="50%" style="stop-color:#888;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#222;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="gripGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#111;stop-opacity:1" />
                                    <stop offset="50%" style="stop-color:#222;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#111;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <path d="M 40 80 Q 40 40 100 50 L 110 52" fill="none" stroke="url(#metalGradient)" stroke-width="12" stroke-linecap="round" />
                            <path d="M 40 75 L 40 130" fill="none" stroke="url(#gripGradient)" stroke-width="14" stroke-linecap="butt" />
                            <path d="M 32 85 L 48 85 M 32 95 L 48 95 M 32 105 L 48 105" stroke="#333" stroke-width="1" />
                            <path d="M 300 80 Q 300 40 240 50 L 230 52" fill="none" stroke="url(#metalGradient)" stroke-width="12" stroke-linecap="round" />
                            <path d="M 300 75 L 300 130" fill="none" stroke="url(#gripGradient)" stroke-width="14" stroke-linecap="butt" />
                            <path d="M 292 85 L 308 85 M 292 95 L 308 95 M 292 105 L 308 105" stroke="#333" stroke-width="1" />
                        </svg>

                        <div class="radar-container">
                            <div class="radar-grid"></div>
                            <div class="radar-ship"></div>
                            <div class="radar-blip blip-home" id="radar-blip-home"></div>
                            <div class="radar-blip blip-target" id="radar-blip-target"></div>
                        </div>
                    </div>
                    <div class="label" style="opacity: 0.5;">RADAR</div>
                </div>

                <div class="screen-section screen-right">
                    <div class="data-row" style="justify-content: flex-end;">
                        <div class="data-value" style="color:#fff;" id="hud-target">SOLAR</div>
                        <div class="label">TARGET</div>
                    </div>
                    <div class="data-row" style="justify-content: flex-end;">
                        <div class="data-value" id="hud-dist">0</div>
                        <div class="unit">AU</div>
                    </div>
                    <div class="data-row" style="justify-content: flex-end;">
                        <div class="data-value data-big" id="hud-speed">0</div>
                        <div class="unit" style="align-self: flex-end; margin-bottom: 5px;">KM/S</div>
                    </div>
                </div>

            </div>
        </div>
    </div>

<script>
    // --- GLOBAL VARIABLES & SETUP ---
    const textureLoader = new THREE.TextureLoader(); 
    const dummy = new THREE.Object3D(); // Fixed scope for animations
    const animatedBelts = []; // Store all asteroid belts here
    const systemGroups = []; // Store all star system groups here for rotation

    function createNoiseTexture(type, color1, color2) {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const idata = ctx.createImageData(size, size);
        const buffer32 = new Uint32Array(idata.data.buffer);
        const c1 = new THREE.Color(color1);
        const c2 = new THREE.Color(color2);

        for (let i = 0; i < buffer32.length; i++) {
            const noise = Math.random();
            let r, g, b;
            
            if (type === 'asteroid') {
                const n = Math.random();
                const mix = n > 0.6 ? 0.3 : (n < 0.2 ? 0.8 : 0.5); 
                r = c1.r * mix + c2.r * (1 - mix);
                g = c1.g * mix + c2.g * (1 - mix);
                b = c1.b * mix + c2.b * (1 - mix);
            } else if (type === 'gas') {
                const y = Math.floor(i / size);
                const band = Math.sin(y * 0.05) * 0.5 + 0.5;
                const mix = band * noise;
                r = c1.r * mix + c2.r * (1 - mix);
                g = c1.g * mix + c2.g * (1 - mix);
                b = c1.b * mix + c2.b * (1 - mix);
            } else {
                const mix = noise;
                r = c1.r * mix + c2.r * (1 - mix);
                g = c1.g * mix + c2.g * (1 - mix);
                b = c1.b * mix + c2.b * (1 - mix);
            }
            buffer32[i] = (255 << 24) | ((b * 255) << 16) | ((g * 255) << 8) | ((r * 255));
        }
        ctx.putImageData(idata, 0, 0);
        return new THREE.CanvasTexture(canvas);
    }

    function createStarTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32,32,0,32,32,32);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.8)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(canvas);
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205);
    scene.fog = new THREE.FogExp2(0x000000, 0.0000001); 

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 50000000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x222222);
    scene.add(ambientLight);

    function addStarLight(pos, color, intensity) {
        const light = new THREE.PointLight(color, intensity, 0, 1);
        light.position.set(pos.x, pos.y, pos.z);
        scene.add(light);
        return light;
    }

    const starTexture = createStarTexture();
    const asteroidTexture = createNoiseTexture('asteroid', '#666666', '#222222');
    const planetMeshes = [];
    
    // --- Solar System ---
    const solarGroup = new THREE.Group();
    scene.add(solarGroup);
    systemGroups.push(solarGroup); // Add to rotating systems
    
    const sun = new THREE.Mesh(new THREE.SphereGeometry(2000, 64, 64), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
    solarGroup.add(sun);
    const sunGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: starTexture, color: 0xffaa00, blending: THREE.AdditiveBlending }));
    sunGlow.scale.set(12000, 12000, 1);
    solarGroup.add(sunGlow);
    addStarLight({x:0,y:0,z:0}, 0xffffff, 2);

    function createPlanet(size, distance, color1, color2, type, name, selfRotSpeed = 0.5) {
        const geo = new THREE.SphereGeometry(size, 64, 64);
        const tex = createNoiseTexture(type, color1, color2);
        const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8, metalness: 0.1 });
        const mesh = new THREE.Mesh(geo, mat);
        const angle = Math.random() * Math.PI * 2;
        mesh.position.set(Math.cos(angle) * distance, 0, Math.sin(angle) * distance);
        solarGroup.add(mesh);
        
        const orbitalSpeed = (1 / Math.sqrt(distance)) * 200;

        mesh.userData = { 
            name: name, type: 'planet', distance: distance, angle: angle, speed: orbitalSpeed, rotSpeed: selfRotSpeed
        };
        planetMeshes.push(mesh);
        return mesh;
    }

    createPlanet(50, 3000, '#A5A5A5', '#5A5A5A', 'rock', 'Mercury', 0.1); 
    createPlanet(120, 5000, '#E6E6C8', '#C8C896', 'gas', 'Venus', -0.05); 
    createPlanet(130, 8000, '#2244AA', '#11AA44', 'earth', 'Earth', 1.0); 
    createPlanet(70, 12000, '#FF4500', '#8B0000', 'rock', 'Mars', 0.9); 

    function createAsteroidBelt(group, count, minRadius, maxRadius, colorStr) {
        const asteroidGeo = new THREE.DodecahedronGeometry(20, 0); 
        const beltMat = new THREE.MeshStandardMaterial({ 
            map: asteroidTexture, roughness: 0.9, color: new THREE.Color(colorStr) 
        });
        const mesh = new THREE.InstancedMesh(asteroidGeo, beltMat, count);
        const data = []; 

        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = minRadius + Math.random() * (maxRadius - minRadius);
            const y = (Math.random() - 0.5) * 1000;
            
            dummy.position.set(Math.cos(angle) * dist, y, Math.sin(angle) * dist);
            dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            const s = Math.random() * 2 + 0.5;
            dummy.scale.set(s,s,s);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
            
            data.push({ angle: angle, dist: dist, y: y, speed: (1/Math.sqrt(dist))*200, rotSpeed: Math.random() });
        }
        group.add(mesh);
        return { mesh, data };
    }

    const solarBelt = createAsteroidBelt(solarGroup, 4000, 16000, 20000, '#aaaaaa');
    animatedBelts.push(solarBelt); // Add to animation loop

    createPlanet(1200, 26000, '#C88B3A', '#A57164', 'gas', 'Jupiter', 2.5); 
    const saturn = createPlanet(1000, 35000, '#E3E0C0', '#D6C485', 'gas', 'Saturn', 2.3); 
    const rings = new THREE.Mesh(new THREE.RingGeometry(1400, 2200, 64), new THREE.MeshBasicMaterial({ color: 0xD6C485, side: THREE.DoubleSide, transparent: true, opacity: 0.6 }));
    rings.rotation.x = Math.PI / 2;
    saturn.add(rings);
    createPlanet(600, 45000, '#ACDFE8', '#4FB6D6', 'gas', 'Uranus', -1.5); 
    createPlanet(580, 55000, '#4B70DD', '#27439C', 'gas', 'Neptune', 1.8);


    // --- Black Hole (Interstellar Style - FIXED VOLUME) ---
    // User requested 100k coordinates. Scaled 10x for simulation vastness = 1,000,000
    const bhPos = new THREE.Vector3(-1000000, 200000, 1000000);
    const bhGroup = new THREE.Group();
    bhGroup.position.copy(bhPos);
    scene.add(bhGroup);
    planetMeshes.push({ position: bhGroup.position, userData: { name: "GARGANTUA (Black Hole)", isSystem: true, baseScale: 20000 }});

    const bhVertexShader = `
        varying vec3 vWorldPosition;
        void main() {
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
    `;

    // Interstellar Shader with Volumetric Fix
    const bhFragmentShader = `
        uniform float iTime;
        uniform vec3 cameraPos;
        uniform vec3 bhPos;
        varying vec3 vWorldPosition;

        #define MAX_STEPS 180
        #define BH_RADIUS 1.5
        #define DISK_INNER 2.2
        #define DISK_OUTER 22.0
        #define DISK_HEIGHT 0.4 

        float hash(vec3 p) {
            p = fract(p * 0.3183099 + .1);
            p *= 17.0;
            return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
        }

        float noise(in vec3 x) {
            vec3 i = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                        mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                    mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                        mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
        }

        float fbm(vec3 p) {
            float v = 0.0;
            float a = 0.5;
            vec3 shift = vec3(100.0);
            for (int i = 0; i < 5; ++i) {
                v += a * noise(p);
                p = p * 2.0 + shift;
                a *= 0.5;
            }
            return v;
        }

        vec3 getDiskColor(float intensity, float temp) {
            // Brighter Core
            vec3 colorLow = vec3(0.5, 0.1, 0.01); 
            vec3 colorMid = vec3(1.0, 0.6, 0.2); 
            vec3 colorHigh = vec3(1.2, 1.1, 1.0); 
            
            float t = smoothstep(0.0, 1.2, temp);
            vec3 col = mix(colorLow, colorMid, t);
            col = mix(col, colorHigh, smoothstep(0.6, 2.0, temp));
            
            return col * intensity * 5.0; // Boosted Intensity
        }

        void main() {
            vec3 ro = cameraPos;
            vec3 rd = normalize(vWorldPosition - ro);
            
            vec3 pos = ro - bhPos; 
            float scale = 1.0 / 2000.0; 
            pos *= scale;

            vec3 col = vec3(0.0);
            float accumulatedAlpha = 0.0;
            
            float closestDistToBH = 9999.0;
            
            for(int i = 0; i < MAX_STEPS; i++) {
                float distToCenter = length(pos);
                closestDistToBH = min(closestDistToBH, distToCenter);
                
                // Stronger Gravity Lensing
                float bendStrength = 0.45; 
                vec3 toCenter = normalize(-pos);
                float grav = bendStrength / (distToCenter * distToCenter + 0.02); 
                rd = normalize(rd + toCenter * grav);
                
                // Fine-tune step size for Front Disk visibility
                float stepSize = max(0.015, distToCenter * 0.04); 
                if (distToCenter < BH_RADIUS * 2.5) stepSize = 0.015; 
                
                pos += rd * stepSize;

                // Volumetric Disk
                float distToPlane = abs(pos.y);
                if(distToPlane < DISK_HEIGHT * 6.0 && distToCenter > DISK_INNER && distToCenter < DISK_OUTER) {
                    
                    float radialFade = smoothstep(DISK_INNER, DISK_INNER + 0.5, distToCenter) * (1.0 - smoothstep(DISK_OUTER - 4.0, DISK_OUTER, distToCenter));
                    
                    float angle = atan(pos.z, pos.x);
                    // Faster Rotation for spinning effect
                    float rotSpeed = 8.0 / (distToCenter + 0.1);
                    float animAngle = angle + iTime * rotSpeed;
                    
                    // Thicker Noise
                    vec3 noisePos = vec3(cos(animAngle)*distToCenter, sin(animAngle)*distToCenter, pos.y * 3.0);
                    float dens = fbm(noisePos * 2.0); 
                    
                    float verticalFade = exp(-pow(distToPlane / (DISK_HEIGHT), 2.0));
                    float intensity = dens * radialFade * verticalFade;
                    
                    if (intensity > 0.01) {
                        float temp = intensity * 1.8;
                        vec3 pCol = getDiskColor(intensity, temp);
                        float absorption = 0.4 * intensity; // Thicker gas
                        col += pCol * absorption * (1.0 - accumulatedAlpha);
                        accumulatedAlpha += absorption;
                    }
                }

                // Event Horizon (Opaque Black)
                if(distToCenter < BH_RADIUS) {
                    accumulatedAlpha = 1.0; 
                    col = vec3(0.0);
                    break;
                }
                
                if(accumulatedAlpha >= 1.0) break;
            }

            gl_FragColor = vec4(col, min(accumulatedAlpha, 1.0));
        }
    `;

    const bhMaterial = new THREE.ShaderMaterial({
        vertexShader: bhVertexShader,
        fragmentShader: bhFragmentShader,
        uniforms: {
            iTime: { value: 0 },
            cameraPos: { value: new THREE.Vector3() },
            bhPos: { value: bhPos }
        },
        transparent: true,
        blending: THREE.NormalBlending, 
        side: THREE.BackSide // Use BackSide to fly inside the volume
    });

    // Massive Box to prevent clipping (The Fix)
    const bhMesh = new THREE.Mesh(new THREE.BoxGeometry(200000, 200000, 200000), bhMaterial);
    bhGroup.add(bhMesh);

    // Visible Debris Ring (Adjusted for wider disk)
    const bhDebris = createAsteroidBelt(bhGroup, 150, 30000, 45000, '#553322'); 
    animatedBelts.push(bhDebris);

    // --- Other Systems ---
    const neutronGroup = new THREE.Group();
    neutronGroup.position.set(600000, -10000, 600000); 
    scene.add(neutronGroup);
    systemGroups.push(neutronGroup);
    planetMeshes.push({ position: neutronGroup.position, userData: { name: "NEUTRON STAR", isSystem: true, baseScale: 20000 }});
    neutronGroup.add(new THREE.Mesh(new THREE.SphereGeometry(100, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })));
    const neuGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: starTexture, color: 0x00ffff, blending: THREE.AdditiveBlending }));
    neuGlow.scale.set(20000, 20000, 1);
    neutronGroup.add(neuGlow);
    const jetGeo = new THREE.ConeGeometry(50, 4000, 32, 1, true);
    const jetMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
    const jet1 = new THREE.Mesh(jetGeo, jetMat); jet1.position.y = 2000; neutronGroup.add(jet1);
    const jet2 = new THREE.Mesh(jetGeo, jetMat); jet2.position.y = -2000; jet2.rotation.z = Math.PI; neutronGroup.add(jet2);
    neutronGroup.userData.spin = true;

    // --- SIRIUS (Binary System) ---
    const siriusGroup = new THREE.Group();
    // User Coord: [-50,000, -20,000, 30,000] -> Scaled 10x
    siriusGroup.position.set(-500000, -200000, 300000);
    scene.add(siriusGroup);
    systemGroups.push(siriusGroup); // Rotates the whole group, making B orbit A

    // Sirius A (Main Star)
    const siriusA = new THREE.Mesh(new THREE.SphereGeometry(1200, 32, 32), new THREE.MeshBasicMaterial({ color: 0x99ccff }));
    siriusGroup.add(siriusA);
    const sGlow = new THREE.Sprite(new THREE.SpriteMaterial({ map: starTexture, color: 0x99ccff, blending: THREE.AdditiveBlending }));
    sGlow.scale.set(18000, 18000, 1);
    siriusGroup.add(sGlow);

    // Sirius B (White Dwarf Companion)
    const siriusB = new THREE.Mesh(new THREE.SphereGeometry(300, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    siriusB.position.set(8000, 500, 0); // Offset from center
    siriusGroup.add(siriusB);
    const sGlowB = new THREE.Sprite(new THREE.SpriteMaterial({ map: starTexture, color: 0xffffff, blending: THREE.AdditiveBlending }));
    sGlowB.scale.set(4000, 4000, 1);
    siriusB.add(sGlowB);

    addStarLight({x:-500000, y:-200000, z:300000}, 0x99ccff, 2);
    
    // Register for Radar/HUD
    planetMeshes.push({ 
        position: siriusGroup.position, 
        userData: { name: "SIRIUS (Binary)", isSystem: true, glow: sGlow, baseScale: 18000 } 
    });


    function createSystem(name, color, x, y, z) {
        const sysGroup = new THREE.Group();
        sysGroup.position.set(x, y, z);
        const star = new THREE.Mesh(new THREE.SphereGeometry(1000, 32, 32), new THREE.MeshBasicMaterial({ color: color }));
        sysGroup.add(star);
        const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: starTexture, color: color, blending: THREE.AdditiveBlending }));
        glow.scale.set(15000, 15000, 1);
        sysGroup.add(glow);
        addStarLight({x,y,z}, color, 1);
        
        planetMeshes.push({ position: sysGroup.position, userData: { name: name, isSystem: true, glow: glow, baseScale: 15000 } });
        systemGroups.push(sysGroup); // Add to rotating systems
        
        if(name === "VEGA") {
            const belt = createAsteroidBelt(sysGroup, 2000, 5000, 10000, '#88aaff');
            animatedBelts.push(belt); // Animate Vega belt
        }

        scene.add(sysGroup);
    }

    // 3. PROXIMA: [60,000, 15,000, -40,000] -> Scaled 10x
    createSystem("PROXIMA", 0xff0000, 600000, 150000, -400000);
    
    // 5. TRAPPIST-1: [30,000, -40,000, -10,000] -> Scaled 10x
    createSystem("TRAPPIST-1", 0xff5500, 300000, -400000, -100000);

    // 6. VEGA: [-20,000, 30,000, -60,000] -> Scaled 10x
    createSystem("VEGA", 0x4488ff, -200000, 300000, -600000);

    // 7. KEPLER-186: [80,000, -10,000, 50,000] -> Scaled 10x
    createSystem("KEPLER-186", 0xffaa55, 800000, -100000, 500000);

    // 8. ZARMINA: [-50,000, 50,000, 10,000] -> Scaled 10x
    createSystem("ZARMINA", 0x55ff55, -500000, 500000, 100000);

    // 9. ANTARES: [10,000, 80,000, -20,000] -> Scaled 10x
    createSystem("ANTARES", 0xff3300, 100000, 800000, -200000);

    // --- Environment ---
    const starGeo = new THREE.BufferGeometry();
    const starCount = 10000; 
    const starPos = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 400000; 
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({
        color: 0xffffff, size: 400, map: starTexture, transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending
    });
    const starField = new THREE.Points(starGeo, starMat);
    scene.add(starField);

    const dustGeo = new THREE.BufferGeometry();
    const dustCount = 3000;
    const dustPos = new Float32Array(dustCount * 3);
    for(let i=0; i<dustCount*3; i++) dustPos[i] = (Math.random() - 0.5) * 100000;
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    const dustMat = new THREE.PointsMaterial({
        color: 0x88aaff, size: 600, map: starTexture, transparent: true, opacity: 0.15, depthWrite: false, blending: THREE.AdditiveBlending
    });
    const dustSystem = new THREE.Points(dustGeo, dustMat);
    scene.add(dustSystem);

    // --- LOGIC ---
    // Start in Outer Solar System (Z = 55,000 approx)
    camera.position.set(0, 5000, 55000); 
    camera.lookAt(new THREE.Vector3(0, 0, 0)); // Look at Sun

    let speed = 0;
    const friction = 0.98;

    const keys = { w: false, s: false };
    const mouse = { x: 0, y: 0 };
    let drag = { active: false, x: 0, y: 0, startX: 0, startY: 0 };

    window.addEventListener('keydown', e => { if(e.key.toLowerCase() === 'w') keys.w = true; if(e.key.toLowerCase() === 's') keys.s = true; });
    window.addEventListener('keyup', e => { if(e.key.toLowerCase() === 'w') keys.w = false; if(e.key.toLowerCase() === 's') keys.s = false; });
    document.addEventListener('mousemove', e => { if (!drag.active) { mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; } });

    const btnWarp = document.getElementById('btn-warp');
    const btnBrake = document.getElementById('btn-brake');
    btnWarp.addEventListener('touchstart', (e) => { e.preventDefault(); keys.w = true; });
    btnWarp.addEventListener('touchend', (e) => { e.preventDefault(); keys.w = false; });
    btnBrake.addEventListener('touchstart', (e) => { e.preventDefault(); keys.s = true; });
    btnBrake.addEventListener('touchend', (e) => { e.preventDefault(); keys.s = false; });

    document.addEventListener('touchstart', e => { if(e.target.className !== 'touch-btn') { drag.active = true; drag.startX = e.touches[0].clientX; drag.startY = e.touches[0].clientY; } }, {passive: false});
    document.addEventListener('touchmove', e => { 
        if(drag.active) { 
            e.preventDefault(); 
            const dx = e.touches[0].clientX - drag.startX; 
            const dy = e.touches[0].clientY - drag.startY; 
            mouse.x = THREE.MathUtils.clamp(dx / 100, -1, 1); 
            mouse.y = THREE.MathUtils.clamp(-dy / 100, -1, 1); 
        } 
    }, {passive: false});
    const endDrag = () => { drag.active = false; mouse.x = 0; mouse.y = 0; };
    document.addEventListener('touchend', endDrag);
    document.addEventListener('touchcancel', endDrag); 

    const compassTape = document.getElementById('compass-tape');
    for(let i=0; i<360; i+=5) {
        const div = document.createElement('div');
        div.className = i % 45 === 0 ? 'tick major' : 'tick';
        div.innerHTML = i % 45 === 0 ? `<span>${i}</span>` : '';
        compassTape.appendChild(div);
    }
    compassTape.innerHTML += compassTape.innerHTML;

    const steeringHandle = document.getElementById('steering-handle');
    const blipHome = document.getElementById('radar-blip-home');
    const blipTarget = document.getElementById('radar-blip-target');
    const hudCoords = document.getElementById('hud-coords');
    const hudSpeed = document.getElementById('hud-speed');
    const hudTarget = document.getElementById('hud-target');
    const hudDist = document.getElementById('hud-dist');

    const clock = new THREE.Clock();
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = Date.now() * 0.001;

        const globalPulse = 1.0 + Math.sin(time * 3) * 0.2;

        euler.setFromQuaternion(camera.quaternion);
        euler.y -= mouse.x * 0.5 * delta;
        euler.x += mouse.y * 0.5 * delta;
        euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
        camera.quaternion.setFromEuler(euler);
        camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, -mouse.x * 0.5, 5 * delta);

        if (keys.w) speed += 1000;
        if (keys.s) speed -= 1000;
        speed *= friction;
        if (Math.abs(speed) < 1) speed = 0;
        camera.translateZ(-speed * delta);

        const steerAngle = mouse.x * 45;
        steeringHandle.style.transform = `rotate(${steerAngle}deg)`;

        starField.position.copy(camera.position);
        const range = 100000;
        dustSystem.position.x = Math.floor(camera.position.x / range) * range;
        dustSystem.position.y = Math.floor(camera.position.y / range) * range;
        dustSystem.position.z = Math.floor(camera.position.z / range) * range;

        bhMaterial.uniforms.iTime.value = time;
        bhMaterial.uniforms.cameraPos.value.copy(camera.position);
        bhMesh.lookAt(camera.position);

        planetMeshes.forEach(mesh => {
            if (mesh.userData.type === 'planet') {
                mesh.userData.angle += mesh.userData.speed * delta * 0.1;
                mesh.position.x = Math.cos(mesh.userData.angle) * mesh.userData.distance;
                mesh.position.z = Math.sin(mesh.userData.angle) * mesh.userData.distance;
                mesh.rotation.y += mesh.userData.rotSpeed * delta;
            }
            if (mesh.userData.isSystem && mesh.userData.glow) {
                const dist = camera.position.distanceTo(mesh.position);
                let scaleFactor = 50000 / Math.max(dist, 10000); 
                scaleFactor = Math.min(Math.max(scaleFactor, 0.05), 1.0); 
                if (dist > 200000) scaleFactor = Math.max(scaleFactor, 0.15);

                const finalScale = mesh.userData.baseScale * scaleFactor * globalPulse;
                mesh.userData.glow.scale.set(finalScale, finalScale, 1);
                // Reduced opacity to avoid hiding star structure
                mesh.userData.glow.material.opacity = Math.min(scaleFactor * 2.0, 0.3); 
            }
        });

        // Rotate Systems
        systemGroups.forEach(group => {
            group.rotation.y += 0.05 * delta;
        });

        // Animate Belts
        animatedBelts.forEach(belt => {
            if(belt) {
                const { mesh, data } = belt;
                for(let i=0; i<data.length; i++) {
                    const d = data[i];
                    d.angle += d.speed * delta * 0.1;
                    dummy.position.set(Math.cos(d.angle) * d.dist, d.y, Math.sin(d.angle) * d.dist);
                    dummy.rotation.set(time * d.rotSpeed, time * d.rotSpeed, 0); 
                    const s = (i % 3) + 0.5; 
                    dummy.scale.set(s,s,s);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
            }
        });

        neutronGroup.rotation.y += 15 * delta;

        // HUD
        let heading = THREE.MathUtils.radToDeg(euler.y);
        heading = (heading % 360 + 360) % 360;
        const tapeOffset = heading * 8; 
        compassTape.style.transform = `translateX(-${tapeOffset}px)`;

        hudCoords.innerText = `${camera.position.x.toFixed(0)}, ${camera.position.y.toFixed(0)}, ${camera.position.z.toFixed(0)}`;
        hudSpeed.innerHTML = `${Math.abs(speed).toFixed(0)}`;

        let nearestDist = Infinity;
        let nearestName = "None";
        let nearestPos = null;

        planetMeshes.forEach(obj => {
            const worldPos = new THREE.Vector3();
            if (obj.isMesh || obj.isGroup) {
               worldPos.copy(obj.position);
               if(obj.parent && obj.parent !== scene) worldPos.applyMatrix4(obj.parent.matrixWorld);
            } else {
                worldPos.copy(obj.position);
            }

            const dist = camera.position.distanceTo(worldPos);
            if (dist < nearestDist) {
                nearestDist = dist;
                nearestName = obj.userData.name;
                nearestPos = worldPos;
            }
        });

        hudTarget.innerText = nearestName;
        hudDist.innerText = (nearestDist / 1000).toFixed(2);

        function updateBlip(blipEl, targetPos, isTarget) {
            if (!targetPos) { blipEl.style.opacity = 0; return; }
            const relPos = new THREE.Vector3().subVectors(targetPos, camera.position);
            relPos.applyQuaternion(camera.quaternion.clone().invert());
            
            const angle = Math.atan2(relPos.x, -relPos.z);
            let distFactor = relPos.length() / 100000;
            distFactor = Math.min(distFactor, 1); 
            if(relPos.length() < 5000) distFactor = relPos.length() / 5000 * 0.2; 

            const rx = Math.sin(angle) * distFactor;
            const ry = -Math.cos(angle) * distFactor;
            
            blipEl.style.left = `${60 + rx * 50}px`; 
            blipEl.style.top = `${60 + ry * 50}px`;
            
            if(isTarget) {
                blipEl.style.opacity = (relPos.z > 0 ? 0.4 : 1) * globalPulse;
                blipEl.style.transform = `translate(-50%, -50%) scale(${globalPulse})`;
            } else {
                blipEl.style.opacity = relPos.z > 0 ? 0.4 : 1;
            }
        }

        updateBlip(blipHome, new THREE.Vector3(0,0,0), false);
        if (nearestPos) updateBlip(blipTarget, nearestPos, true); else blipTarget.style.opacity = 0;

        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
